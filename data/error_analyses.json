{
  "2d146bee0208": {
    "analysis": "## An\u00e1lisis del Error Django\n\n### 1. **Resumen**\nLa aplicaci\u00f3n Django falla al inicializar debido a un `NameError` donde la clase `Colaborador` no est\u00e1 definida o no est\u00e1 disponible en el contexto donde se intenta usar en el modelo `ComiteProyecto`. Este error ocurre durante la importaci\u00f3n de modelos en el proceso de startup de Django.\n\n### 2. **Causa Probable**\n- **Orden de importaci\u00f3n incorrecto**: La clase `Colaborador` se est\u00e1 referenciando antes de ser definida\n- **Importaci\u00f3n faltante**: No se est\u00e1 importando la clase `Colaborador` en `models_original.py`\n- **Dependencia circular**: Posible referencia circular entre modelos\n- **Modelo eliminado**: La clase `Colaborador` fue eliminada pero sigue siendo referenciada\n\n### 3. **Impacto**\n**Nivel: CR\u00cdTICO**\n- La aplicaci\u00f3n no puede inicializar completamente\n- Impide el funcionamiento de cualquier funcionalidad de la aplicaci\u00f3n\n- 328 ocurrencias indican que el problema es persistente y afecta todos los deployments\n\n### 4. **Soluci\u00f3n Sugerida**\n\n```python\n# Opci\u00f3n 1: Importar la clase Colaborador\nfrom .models import Colaborador  # o desde donde est\u00e9 definida\n\n# Opci\u00f3n 2: Si est\u00e1 en el mismo archivo, mover la definici\u00f3n antes\nclass Colaborador(models.Model):\n    # definici\u00f3n del modelo\n    pass\n\nclass ComiteProyecto(models.Model):\n    # ... otros campos\n    Colaborador,  # ahora est\u00e1 disponible\n```\n\n**Pasos inmediatos:**\n1. Verificar si existe la clase `Colaborador` en el proyecto\n2. A\u00f1adir la importaci\u00f3n correspondiente en `models_original.py`\n3. Si hay dependencias circulares, usar `'app.Model'` como string\n4. Ejecutar `python manage.py makemigrations` y `migrate`\n5. Realizar deployment\n\n### 5. **Prevenci\u00f3n**\n- **Testing local**: Ejecutar `python manage.py check` antes de deployments\n- **CI/CD**: Incluir validaci\u00f3n de modelos en el pipeline\n- **Gesti\u00f3n de dependencias**: Documentar relaciones entre modelos\n- **Code review**: Revisar cambios en models.py especialmente imports y referencias",
    "analyzed_at": "2026-02-04T07:00:53.350918+00:00"
  },
  "c0172d753507": {
    "analysis": "## An\u00e1lisis del Error - Django en Google Cloud Run\n\n### 1. **Resumen**\nLa aplicaci\u00f3n Django est\u00e1 devolviendo respuestas malformadas o experimentando errores de conexi\u00f3n, resultando en c\u00f3digos de estado HTTP 503. La alta latencia (11+ segundos) indica problemas de rendimiento o timeout en el servicio.\n\n### 2. **Causa Probable**\n- **Timeout de la aplicaci\u00f3n**: Django no responde dentro del l\u00edmite de tiempo de Cloud Run (hasta 60 minutos, pero probablemente configurado menor)\n- **Sobrecarga de recursos**: CPU/memoria insuficientes causando lentitud extrema\n- **Error en el c\u00f3digo**: Bucles infinitos, consultas de base de datos lentas o bloqueos\n- **Problemas de configuraci\u00f3n**: Settings incorrectos de Django o variables de entorno faltantes\n\n### 3. **Impacto**\n**Nivel: CR\u00cdTICO**\n- 231 ocurrencias en 7 d\u00edas indica un problema persistente\n- Error 503 significa servicio no disponible para los usuarios\n- Afecta la experiencia del usuario y disponibilidad del sistema\n- Puede impactar la reputaci\u00f3n del servicio\n\n### 4. **Soluci\u00f3n Sugerida**\n\n**Inmediato:**\n```bash\n# 1. Revisar logs detallados\ngcloud logging read \"resource.type=cloud_run_revision AND resource.labels.service_name=rgd-aire-staging\" --limit=100\n\n# 2. Aumentar recursos temporalmente\ngcloud run services update rgd-aire-staging \\\n  --cpu=2 --memory=2Gi --timeout=300s \\\n  --region=us-central1\n```\n\n**Investigaci\u00f3n:**\n- Revisar logs de Django para errores espec\u00edficos\n- Identificar consultas SQL lentas con Django Debug Toolbar\n- Verificar configuraci\u00f3n de `ALLOWED_HOSTS` y middleware\n- Comprobar conectividad a base de datos\n\n### 5. **Prevenci\u00f3n**\n- **Monitoreo**: Implementar health checks y alertas de latencia\n- **Optimizaci\u00f3n**: Cachear consultas frecuentes y optimizar ORM\n- **Configuraci\u00f3n**: Establecer timeouts apropiados y limits de recursos\n- **Testing**: Pruebas de carga para identificar cuellos de botella\n- **Logging**: Implementar logging estructurado para mejor debugging",
    "analyzed_at": "2026-02-04T07:01:05.489004+00:00"
  },
  "3acc476fc9f4": {
    "analysis": "## An\u00e1lisis del Error\n\n### 1. **Resumen**\nLa aplicaci\u00f3n Django est\u00e1 fallando durante el inicio en Cloud Run debido a un `NameError` que ocurre cuando Gunicorn intenta cargar la aplicaci\u00f3n WSGI. El error se produce en el archivo `wsgi.py` al llamar a `get_wsgi_application()`, indicando que hay una variable o m\u00f3dulo no definido.\n\n### 2. **Causa Probable**\n- **Variable no definida**: Falta importar un m\u00f3dulo o definir una variable necesaria en `wsgi.py` o en los settings de Django\n- **Configuraci\u00f3n de Django incompleta**: `DJANGO_SETTINGS_MODULE` no est\u00e1 configurado correctamente\n- **Dependencias faltantes**: Alg\u00fan paquete requerido no est\u00e1 instalado en el contenedor\n- **Error en variables de entorno**: Variables cr\u00edticas no est\u00e1n definidas en Cloud Run\n\n### 3. **Impacto**\n**Nivel: CR\u00cdTICO**\n- La aplicaci\u00f3n no puede iniciar, resultando en 100% de downtime\n- 164 ocurrencias en 7 d\u00edas indica un problema persistente\n- Afecta completamente la disponibilidad del servicio en staging\n\n### 4. **Soluci\u00f3n Sugerida**\n\n**Pasos inmediatos:**\n1. **Verificar `wsgi.py`**:\n   ```python\n   import os\n   from django.core.wsgi import get_wsgi_application\n   \n   os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'rgd_aire.settings')\n   application = get_wsgi_application()\n   ```\n\n2. **Revisar variables de entorno en Cloud Run**:\n   ```bash\n   gcloud run services describe rgd-aire-staging --region=[REGION]\n   ```\n\n3. **Verificar Dockerfile y requirements.txt**:\n   - Asegurar que todas las dependencias est\u00e1n instaladas\n   - Confirmar que el `WORKDIR` y `PYTHONPATH` est\u00e1n correctos\n\n4. **Revisar logs detallados**:\n   ```bash\n   gcloud logs read --service=rgd-aire-staging --limit=50\n   ```\n\n### 5. **Prevenci\u00f3n**\n\n**Medidas a implementar:**\n- **Testing local**: Probar el contenedor localmente antes del deploy\n- **Health checks**: Implementar endpoints de salud para detectar problemas temprano\n- **CI/CD robusto**: Agregar tests de smoke que validen el startup de la aplicaci\u00f3n\n- **Monitoreo**: Configurar alertas para errores de startup\n- **Rollback autom\u00e1tico**: Configurar Cloud Run para hacer rollback autom\u00e1tico en caso de fallos\n\n**Comando de validaci\u00f3n local:**\n```bash\ndocker build -t rgd-aire-test .\ndocker run -p 8080:8080 rgd-aire-test\n```",
    "analyzed_at": "2026-02-04T07:01:18.499206+00:00"
  },
  "7094027ff185": {
    "analysis": "## An\u00e1lisis del Error en Django/Cloud Run\n\n### 1. **Resumen**\nError 500 recurrente en el endpoint `/reportes/produccion/` con alta latencia (4.47 segundos). El mensaje de error est\u00e1 vac\u00edo, sugiriendo un fallo silencioso o timeout interno.\n\n### 2. **Causa Probable**\n- **Timeout de procesamiento**: La alta latencia indica operaciones costosas (consultas DB complejas, procesamientos pesados)\n- **Error no capturado**: Exception silenciosa sin logging adecuado\n- **L\u00edmites de memoria/CPU**: Cloud Run alcanzando l\u00edmites de recursos\n- **Dependencia externa fallando**: APIs, servicios externos o conexiones DB\n\n### 3. **Impacto**\n**Nivel: ALTO**\n- 34 ocurrencias en 4 d\u00edas indica problema sistem\u00e1tico\n- Endpoint cr\u00edtico de reportes afectado\n- Experiencia de usuario degradada (4+ segundos de espera)\n- P\u00e9rdida de funcionalidad de negocio importante\n\n### 4. **Soluci\u00f3n Sugerida**\n```bash\n# Paso 1: Habilitar logging detallado\n# En settings.py\nLOGGING = {\n    'version': 1,\n    'handlers': {\n        'console': {\n            'class': 'logging.StreamHandler',\n            'level': 'ERROR',\n        },\n    },\n    'root': {\n        'handlers': ['console'],\n        'level': 'ERROR',\n    },\n}\n\n# Paso 2: Revisar la vista problem\u00e1tica\ndef reportes_produccion(request):\n    try:\n        # Tu c\u00f3digo actual\n        pass\n    except Exception as e:\n        logger.error(f\"Error en reportes produccion: {str(e)}\")\n        raise\n\n# Paso 3: Aumentar recursos de Cloud Run\ngcloud run services update carnesdelsebastian \\\n    --memory=2Gi \\\n    --cpu=2 \\\n    --timeout=900s \\\n    --region=us-central1\n```\n\n### 5. **Prevenci\u00f3n**\n- **Monitoring**: Implementar APM (Google Cloud Monitoring/Sentry)\n- **Optimizaci\u00f3n DB**: Indexar consultas, usar select_related/prefetch_related\n- **Cache**: Implementar Redis/Memcache para reportes pesados\n- **Pagination**: Limitar cantidad de datos procesados\n- **Health checks**: Endpoints de monitoreo proactivo",
    "analyzed_at": "2026-02-04T07:01:31.146818+00:00"
  },
  "4711160f70ba": {
    "analysis": "## **Resumen**\nError `FieldError` en Django al intentar hacer una anotaci\u00f3n con `Avg()` sobre un campo que no existe en el modelo o est\u00e1 mal referenciado. El error ocurre en la vista de reportes de producci\u00f3n cuando se intenta calcular promedios por mes.\n\n## **Causa Probable**\n- La variable `campo_hist` contiene un nombre de campo que no existe en el modelo del queryset `qs_hist`\n- El campo puede estar mal escrito (typo) o no estar disponible en las relaciones del modelo\n- Posible inconsistencia entre el esquema de base de datos y el modelo Django\n\n## **Impacto**\n**Nivel: ALTO**\n- 33 ocurrencias en 4 d\u00edas indica un problema frecuente\n- Afecta funcionalidad cr\u00edtica de reportes de producci\u00f3n\n- Los usuarios no pueden acceder a datos de an\u00e1lisis importantes\n- Puede impactar decisiones de negocio basadas en reportes\n\n## **Soluci\u00f3n Sugerida**\n\n### Paso 1: Verificar el campo\n```python\n# En views_produccion.py l\u00ednea ~358\nprint(f\"Campo hist\u00f3rico: {campo_hist}\")\nprint(f\"Campos disponibles: {[f.name for f in qs_hist.model._meta.get_fields()]}\")\n```\n\n### Paso 2: Validar antes de anotar\n```python\n# Agregar validaci\u00f3n antes de la anotaci\u00f3n\nif hasattr(qs_hist.model, campo_hist):\n    for registro in qs_hist.values('mes').annotate(valor=Avg(campo_hist)):\n        # proceso\nelse:\n    # manejar error o campo por defecto\n    logger.error(f\"Campo {campo_hist} no encontrado en modelo {qs_hist.model}\")\n```\n\n### Paso 3: Revisar mapeo de campos\nVerificar que `campo_hist` est\u00e9 correctamente mapeado en el m\u00e9todo que lo genera.\n\n## **Prevenci\u00f3n**\n\n1. **Validaci\u00f3n de campos**: Implementar validaci\u00f3n de existencia de campos antes de usar en queries\n2. **Tests unitarios**: Crear tests para todos los campos usados en anotaciones\n3. **Logging mejorado**: Agregar logs para debuggear valores de variables din\u00e1micas\n4. **Documentaci\u00f3n**: Mantener documentaci\u00f3n actualizada de campos disponibles por modelo\n5. **Migration checks**: Verificar que las migraciones est\u00e9n aplicadas correctamente en producci\u00f3n",
    "analyzed_at": "2026-02-04T07:01:43.517651+00:00"
  },
  "7c53966e6a9b": {
    "analysis": "## An\u00e1lisis del Error\n\n### 1. **Resumen**\nLa aplicaci\u00f3n Django est\u00e1 devolviendo errores HTTP 500 (Error Interno del Servidor) en el endpoint de registro de desperdicios del turno de sellado. El error ha ocurrido 28 veces en los \u00faltimos d\u00edas, pero no se proporciona el stack trace espec\u00edfico del error.\n\n### 2. **Causa Probable**\nSin el mensaje de error espec\u00edfico, las causas m\u00e1s comunes para un HTTP 500 en este contexto son:\n- **Error de base de datos**: Problemas de conexi\u00f3n, constraints violados, o queries malformados\n- **Error de validaci\u00f3n**: Datos inv\u00e1lidos en el formulario de registro de desperdicios\n- **Error de permisos**: Falta de permisos para escribir en la base de datos\n- **Error de l\u00f3gica de negocio**: Exception no capturada en el c\u00f3digo de la vista\n\n### 3. **Impacto**\n**Severidad: ALTO**\n- Afecta directamente la funcionalidad de producci\u00f3n (registro de desperdicios)\n- 28 ocurrencias indican un problema persistente\n- Impacta la operaci\u00f3n diaria y el control de calidad/costos\n\n### 4. **Soluci\u00f3n Sugerida**\n```bash\n# 1. Revisar logs detallados de Cloud Run\ngcloud logging read \"resource.type=cloud_run_revision AND resource.labels.service_name=arcopack-erp\" --limit=50\n\n# 2. Activar logging detallado en Django (settings.py)\nLOGGING = {\n    'version': 1,\n    'handlers': {\n        'console': {\n            'class': 'logging.StreamHandler',\n            'level': 'ERROR',\n        },\n    },\n    'root': {\n        'handlers': ['console'],\n    },\n}\n\n# 3. Agregar manejo de excepciones en la vista\ntry:\n    # l\u00f3gica de registro de desperdicios\nexcept Exception as e:\n    logger.error(f\"Error registrando desperdicio: {str(e)}\")\n    return JsonResponse({'error': 'Error interno'}, status=500)\n```\n\n### 5. **Prevenci\u00f3n**\n- **Implementar logging comprehensivo** en todas las vistas cr\u00edticas\n- **Agregar validaci\u00f3n robusta** de datos de entrada\n- **Implementar health checks** para monitorear la conectividad de BD\n- **Configurar alertas proactivas** en Google Cloud Monitoring\n- **Realizar testing de carga** en endpoints de producci\u00f3n cr\u00edticos\n\n**Acci\u00f3n Inmediata**: Revisar los logs completos de Cloud Run para obtener el stack trace espec\u00edfico del error.",
    "analyzed_at": "2026-02-04T07:01:56.610539+00:00"
  },
  "fe9cd8cd9890": {
    "analysis": "## An\u00e1lisis del Error\n\n### 1. **Resumen**\nEl endpoint de health check `/api/health/` est\u00e1 devolviendo errores HTTP 500 con latencias muy altas (8+ segundos) en 28 ocasiones durante 3 d\u00edas. Esto indica un fallo sistem\u00e1tico en el servicio de monitoreo de salud de la aplicaci\u00f3n Django.\n\n### 2. **Causa Probable**\n- **Timeout de base de datos**: El health check probablemente incluye verificaci\u00f3n de conectividad a la BD que est\u00e1 fallando\n- **Recursos agotados**: CPU/memoria insuficientes en Cloud Run causando timeouts\n- **Dependencias externas**: Servicios de terceros no disponibles que el health check intenta validar\n- **Configuraci\u00f3n incorrecta**: Variables de entorno o credenciales faltantes/incorrectas\n\n### 3. **Impacto**\n**Nivel: ALTO**\n- Los health checks fallidos pueden causar que Cloud Run reinicie constantemente los contenedores\n- Afecta la disponibilidad general del servicio\n- Impide el monitoreo efectivo del estado real de la aplicaci\u00f3n\n- La IP `34.174.217.145` sugiere que son health checks autom\u00e1ticos de Google Cloud\n\n### 4. **Soluci\u00f3n Sugerida**\n```python\n# 1. Revisar el endpoint /api/health/ en Django\n# 2. Implementar health check m\u00e1s robusto:\ndef health_check(request):\n    try:\n        # Verificaci\u00f3n b\u00e1sica sin dependencias pesadas\n        from django.db import connection\n        with connection.cursor() as cursor:\n            cursor.execute(\"SELECT 1\")  # Query simple\n        return JsonResponse({\"status\": \"healthy\"}, status=200)\n    except Exception as e:\n        return JsonResponse({\"status\": \"unhealthy\", \"error\": str(e)}, status=503)\n\n# 3. Ajustar configuraci\u00f3n de Cloud Run:\n# - Aumentar timeout a 60s\n# - Incrementar CPU/memoria si es necesario\n# - Configurar health check con mayor intervalo\n```\n\n### 5. **Prevenci\u00f3n**\n- **Implementar health checks ligeros** que no dependan de servicios externos\n- **Configurar alertas proactivas** para monitorear latencia del health check\n- **Usar health checks separados**: uno b\u00e1sico para Cloud Run, otro detallado para monitoreo\n- **Establecer timeouts apropiados** en la configuraci\u00f3n de Cloud Run (30-60 segundos)\n- **Monitorear m\u00e9tricas de recursos** para detectar cuellos de botella antes de que causen fallos",
    "analyzed_at": "2026-02-04T07:02:15.093352+00:00"
  },
  "8b60a2c2fc9f": {
    "analysis": "## **AN\u00c1LISIS DEL ERROR**\n\n### 1. **Resumen**\nEl servicio Django est\u00e1 devolviendo errores HTTP 500 (Internal Server Error) al intentar acceder a la ruta `/produccion/ordenes/`. El error se clasifica como \"Unknown Error\" porque no hay logs espec\u00edficos del stacktrace disponibles en el mensaje.\n\n### 2. **Causa Probable**\n- **Error de aplicaci\u00f3n Django** en la vista que maneja `/produccion/ordenes/`\n- **Problema de base de datos**: conexi\u00f3n perdida, query mal formado, o tabla inexistente\n- **Configuraci\u00f3n incorrecta** de variables de entorno en Cloud Run\n- **Dependencias faltantes** o incompatibles en el contenedor\n- **Timeout de recursos** (memoria/CPU insuficientes)\n\n### 3. **Impacto**\n**Nivel: ALTO**\n- 26 ocurrencias en 2 d\u00edas indica un problema recurrente\n- Afecta funcionalidad cr\u00edtica de producci\u00f3n/\u00f3rdenes\n- Error 500 genera mala experiencia de usuario\n- Latencia de 0.58s es aceptable, descarta problemas de performance\n\n### 4. **Soluci\u00f3n Sugerida**\n```bash\n# 1. Revisar logs detallados\ngcloud logging read \"resource.type=cloud_run_revision AND resource.labels.service_name=plasticos-ambientales\" --limit=50\n\n# 2. Verificar configuraci\u00f3n Django\nkubectl logs [pod-name] --previous\n\n# 3. Validar variables de entorno\ngcloud run services describe plasticos-ambientales --region=us-central1\n\n# 4. Probar localmente la ruta problem\u00e1tica\npython manage.py shell\n# >>> from django.test import Client\n# >>> c = Client()\n# >>> response = c.get('/produccion/ordenes/')\n\n# 5. Incrementar recursos temporalmente\ngcloud run services update plasticos-ambientales --memory=1Gi --cpu=1\n```\n\n### 5. **Prevenci\u00f3n**\n- **Logging mejorado**: Implementar logging detallado con `django.utils.log`\n- **Health checks**: Agregar endpoint `/health/` para monitoreo\n- **Error tracking**: Integrar Sentry o similar para captura de excepciones\n- **Tests automatizados**: Pruebas de integraci\u00f3n para rutas cr\u00edticas\n- **Monitoreo proactivo**: Alertas en Cloud Monitoring para errores 5xx\n- **Graceful degradation**: Manejo de errores con respuestas informativas",
    "analyzed_at": "2026-02-04T07:02:28.994321+00:00"
  },
  "ba9d38f4088e": {
    "analysis": "## An\u00e1lisis del Error\n\n### 1. **Resumen**\nError HTTP 500 recurrente en el endpoint de creaci\u00f3n de acabados de producci\u00f3n, ocurriendo 20 veces en un per\u00edodo de ~1.5 horas con latencias muy altas (~4 segundos). El mensaje de error espec\u00edfico no se muestra, lo que indica un problema en el logging o manejo de excepciones.\n\n### 2. **Causa Probable**\n- **Primaria**: Excepci\u00f3n no capturada en la vista Django que maneja `/produccion/acabado/crear/`\n- **Secundarias**: \n  - Timeout de base de datos o conexi\u00f3n externa\n  - Problema de memoria/recursos en Cloud Run\n  - Error en validaci\u00f3n de datos del formulario POST\n  - Configuraci\u00f3n incorrecta del logging de Django\n\n### 3. **Impacto**\n**Nivel: ALTO**\n- Funcionalidad cr\u00edtica de producci\u00f3n completamente inoperativa\n- 20 fallos consecutivos indican problema sistem\u00e1tico, no espor\u00e1dico\n- Afecta flujo de trabajo de usuarios m\u00f3viles\n- Latencia de 4 segundos sugiere recursos sobrecargados\n\n### 4. **Soluci\u00f3n Sugerida**\n```python\n# Acciones inmediatas:\n1. Revisar logs de Cloud Run: gcloud logging read \"resource.type=cloud_run_revision\"\n2. Verificar la vista en views.py:\n   - A\u00f1adir try/except con logging expl\u00edcito\n   - Validar configuraci\u00f3n de base de datos\n3. Revisar configuraci\u00f3n de Cloud Run:\n   - Aumentar memoria/CPU temporalmente\n   - Verificar variables de entorno\n4. Implementar logging detallado:\n   logger.exception(\"Error en crear acabado\", extra={\"user\": request.user})\n```\n\n### 5. **Prevenci\u00f3n**\n- **Monitoring**: Implementar health checks espec\u00edficos para endpoints cr\u00edticos\n- **Logging**: Configurar `LOGGING` en settings.py para capturar todas las excepciones\n- **Testing**: A\u00f1adir tests de integraci\u00f3n para el flujo completo de creaci\u00f3n\n- **Alertas**: Configurar alertas en Google Cloud Monitoring para errores 500 recurrentes\n- **Timeouts**: Implementar timeouts apropiados para operaciones de base de datos",
    "analyzed_at": "2026-02-04T07:02:40.599240+00:00"
  },
  "20123360fc37": {
    "analysis": "## An\u00e1lisis del Error Django\n\n### 1. **Resumen**\nError de atributo (`AttributeError`) que ocurre durante el renderizado de un template en Django. El error se produce cuando el template engine intenta acceder a un atributo o m\u00e9todo que no existe en el objeto del contexto.\n\n### 2. **Causa Probable**\n- **Template intentando acceder a atributo inexistente**: Variable en el template que referencia un atributo que no existe en el modelo u objeto\n- **Objeto None no esperado**: El contexto contiene un valor `None` donde se esperaba un objeto con propiedades\n- **Cambio en modelo/estructura de datos**: Modificaci\u00f3n reciente en modelos que rompi\u00f3 referencias en templates existentes\n- **Migraci\u00f3n incompleta**: Base de datos desactualizada respecto al c\u00f3digo\n\n### 3. **Impacto**\n**Nivel: ALTO**\n- Afecta la experiencia del usuario (p\u00e1ginas no cargan)\n- 17 ocurrencias en 2 d\u00edas indica problema recurrente\n- Impide el funcionamiento normal de funcionalidades clave\n- Puede afectar m\u00faltiples usuarios del servicio\n\n### 4. **Soluci\u00f3n Sugerida**\n\n```python\n# 1. Revisar logs completos para identificar la l\u00ednea exacta\n# 2. En el template, agregar validaciones:\n{% if objeto.atributo %}\n    {{ objeto.atributo }}\n{% endif %}\n\n# 3. En la vista, verificar contexto:\ndef mi_vista(request):\n    objeto = MiModelo.objects.get(id=1)\n    if not hasattr(objeto, 'atributo_requerido'):\n        # Manejar caso especial\n        pass\n    return render(request, 'template.html', {'objeto': objeto})\n\n# 4. Verificar migraciones:\npython manage.py showmigrations\npython manage.py migrate\n```\n\n### 5. **Prevenci\u00f3n**\n- **Validaciones en templates**: Usar filtros `|default` y condicionales `{% if %}`\n- **Tests de renderizado**: Crear tests que verifiquen el renderizado de templates con diferentes estados de datos\n- **Validaci\u00f3n de contexto**: Verificar que todos los objetos necesarios existan antes de pasarlos al template\n- **Monitoreo proactivo**: Implementar alertas para errores de template en producci\u00f3n\n- **Code review**: Revisar cambios en modelos y sus impactos en templates existentes\n\n**Acci\u00f3n inmediata recomendada**: Revisar los logs completos para identificar el template y l\u00ednea espec\u00edfica que causa el error.",
    "analyzed_at": "2026-02-04T07:02:54.408979+00:00"
  }
}