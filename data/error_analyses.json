{
  "2d146bee0208": {
    "analysis": "## An\u00e1lisis del Error Django\n\n### 1. **Resumen**\nLa aplicaci\u00f3n Django falla al inicializar porque el modelo `Colaborador` no est\u00e1 definido o no es accesible cuando se intenta referenciar en el modelo `ComiteProyecto`. Este es un error de importaci\u00f3n/definici\u00f3n que impide el arranque completo de la aplicaci\u00f3n.\n\n### 2. **Causa Probable**\n- El modelo `Colaborador` no est\u00e1 definido en el archivo `models_original.py` antes de ser referenciado en `ComiteProyecto`\n- Problema de orden de definici\u00f3n de clases en el archivo\n- Import circular o faltante del modelo `Colaborador`\n- El modelo `Colaborador` fue eliminado o renombrado sin actualizar las referencias\n\n### 3. **Impacto**\n**Nivel: CR\u00cdTICO**\n- La aplicaci\u00f3n no puede inicializar Django\n- El servicio est\u00e1 completamente inoperativo (316 ocurrencias)\n- Afecta todo el funcionamiento durante m\u00e1s de una semana\n- Impide cualquier operaci\u00f3n que requiera los modelos de Django\n\n### 4. **Soluci\u00f3n Sugerida**\n```python\n# Opci\u00f3n 1: Definir el modelo Colaborador antes de ComiteProyecto\nclass Colaborador(models.Model):\n    # definici\u00f3n del modelo\n    pass\n\nclass ComiteProyecto(models.Model):\n    # resto del modelo\n    pass\n\n# Opci\u00f3n 2: Si est\u00e1 en otro archivo, agregar import\nfrom .otro_archivo import Colaborador\n\n# Opci\u00f3n 3: Si es referencia de ForeignKey, usar string\nclass ComiteProyecto(models.Model):\n    colaborador = models.ForeignKey('Colaborador', ...)\n```\n\n### 5. **Prevenci\u00f3n**\n- **Validaci\u00f3n pre-deploy**: Ejecutar `python manage.py check` antes de desplegar\n- **Tests de importaci\u00f3n**: Incluir tests que validen la importaci\u00f3n de todos los modelos\n- **CI/CD robusto**: Agregar verificaci\u00f3n de sintaxis y dependencias en el pipeline\n- **Code review**: Revisar cambios en models.py para detectar dependencias rotas\n- **Staging environment**: Probar cambios de modelos en ambiente de staging antes de producci\u00f3n",
    "analyzed_at": "2026-02-02T07:09:31.984684+00:00"
  },
  "c0172d753507": {
    "analysis": "## **1. RESUMEN**\nLa aplicaci\u00f3n Django en Cloud Run est\u00e1 devolviendo errores 503 con respuestas malformadas o fallos de conexi\u00f3n, afectando a los usuarios durante un per\u00edodo de 7 d\u00edas con 228 ocurrencias. El tiempo de latencia de 11.5 segundos indica problemas graves de rendimiento o timeout.\n\n## **2. CAUSA PROBABLE**\n- **Timeout de la aplicaci\u00f3n**: La aplicaci\u00f3n tarda m\u00e1s de 30 segundos (l\u00edmite de Cloud Run) en responder\n- **Problemas de memoria/CPU**: Recursos insuficientes causando que la instancia no responda correctamente\n- **Error en el c\u00f3digo Django**: Excepci\u00f3n no manejada que corrompe la respuesta HTTP\n- **Base de datos lenta**: Consultas que tardan demasiado y provocan timeout\n\n## **3. IMPACTO**\n**Nivel: CR\u00cdTICO**\n- 228 errores en 7 d\u00edas indica un problema persistente\n- Error 503 significa servicio completamente no disponible para usuarios\n- Afecta la p\u00e1gina principal (/) - punto de entrada cr\u00edtico\n- Latencia de 11.5s es inaceptable para experiencia de usuario\n\n## **4. SOLUCI\u00d3N SUGERIDA**\n\n### Inmediato:\n```bash\n# 1. Revisar logs de la aplicaci\u00f3n\ngcloud logging read \"resource.type=cloud_run_revision AND resource.labels.service_name=rgd-aire-staging\" --limit=50\n\n# 2. Aumentar recursos temporalmente\ngcloud run services update rgd-aire-staging \\\n  --memory=2Gi \\\n  --cpu=2 \\\n  --timeout=300s \\\n  --concurrency=80\n```\n\n### Diagn\u00f3stico:\n- Revisar logs de Django para excepciones no capturadas\n- Verificar consultas lentas en la base de datos\n- Monitorear m\u00e9tricas de memoria y CPU en Cloud Monitoring\n\n### Correcci\u00f3n:\n```python\n# A\u00f1adir middleware de timeout en Django\nMIDDLEWARE = [\n    'django.middleware.common.CommonMiddleware',\n    # ... otros middleware\n]\n\n# Optimizar consultas en views problem\u00e1ticas\n# Usar select_related() y prefetch_related()\n```\n\n## **5. PREVENCI\u00d3N**\n\n### Monitoreo:\n- Configurar alertas para errores 5xx > 5% de tr\u00e1fico\n- Alertas de latencia > 5 segundos\n- Monitoreo de memoria/CPU > 80%\n\n### Configuraci\u00f3n:\n```yaml\n# En cloud run service.yaml\nspec:\n  template:\n    metadata:\n      annotations:\n        run.googleapis.com/execution-environment: gen2\n    spec:\n      containerConcurrency: 100\n      timeoutSeconds: 300\n      containers:\n      - resources:\n          limits:\n            memory: \"2Gi\"\n            cpu: \"2000m\"\n```\n\n### C\u00f3digo:\n- Implementar circuit breakers para APIs externas\n- A\u00f1adir \u00edndices de base de datos para consultas lentas\n- Usar cache (Redis/Memcached) para datos frecuentes\n- Health checks robustos en `/health/`",
    "analyzed_at": "2026-02-02T07:09:47.717527+00:00"
  },
  "3acc476fc9f4": {
    "analysis": "## An\u00e1lisis del Error Django en Google Cloud Run\n\n### 1. **Resumen**\nLa aplicaci\u00f3n Django no puede inicializarse correctamente en Gunicorn debido a un `NameError` en el archivo `wsgi.py`. El error ocurre durante el proceso de importaci\u00f3n de m\u00f3dulos necesarios para crear la aplicaci\u00f3n WSGI.\n\n### 2. **Causa Probable**\n- **Variable/m\u00f3dulo no definido**: El archivo `wsgi.py` est\u00e1 intentando usar una variable, funci\u00f3n o m\u00f3dulo que no est\u00e1 definido o no se ha importado correctamente\n- **Error en configuraci\u00f3n de Django**: Posible problema con `DJANGO_SETTINGS_MODULE` o configuraci\u00f3n de settings\n- **Dependencia faltante**: Alg\u00fan paquete requerido no est\u00e1 instalado o no es accesible\n- **Error en el c\u00f3digo**: Typo o referencia incorrecta en `wsgi.py` o en alg\u00fan m\u00f3dulo que se importa durante la inicializaci\u00f3n\n\n### 3. **Impacto**\n**Nivel: CR\u00cdTICO**\n- La aplicaci\u00f3n no puede iniciarse, resultando en 100% de fallos de despliegue\n- 158 ocurrencias en una semana indica reintentos constantes fallidos\n- Servicio completamente inoperativo en el entorno staging\n\n### 4. **Soluci\u00f3n Sugerida**\n\n**Pasos inmediatos:**\n1. **Revisar `/app/rgd_aire/wsgi.py`** l\u00ednea 21:\n   ```bash\n   # Verificar imports y variables definidas antes de get_wsgi_application()\n   ```\n\n2. **Verificar configuraci\u00f3n de Django**:\n   ```python\n   # En wsgi.py, asegurar que existe:\n   import os\n   from django.core.wsgi import get_wsgi_application\n   os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'rgd_aire.settings')\n   ```\n\n3. **Revisar dependencias**:\n   ```bash\n   # Verificar que requirements.txt incluye todas las dependencias\n   pip freeze > current_requirements.txt\n   ```\n\n4. **Probar localmente**:\n   ```bash\n   python manage.py check --deploy\n   python -c \"from rgd_aire.wsgi import application\"\n   ```\n\n### 5. **Prevenci\u00f3n**\n\n**Medidas preventivas:**\n- **CI/CD robusto**: Implementar tests que validen la importaci\u00f3n de wsgi antes del deploy\n- **Health checks**: Configurar probes de readiness/liveness en Cloud Run\n- **Staging testing**: Ejecutar `python -m django check` en pipeline\n- **Dependency pinning**: Fijar versiones exactas en requirements.txt\n- **Logging mejorado**: A\u00f1adir logs detallados en wsgi.py para debug futuro\n- **Rollback autom\u00e1tico**: Configurar reversi\u00f3n autom\u00e1tica si el health check falla\n\n**Comando de verificaci\u00f3n sugerido para CI/CD:**\n```bash\npython -c \"import os; os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'rgd_aire.settings'); from django.core.wsgi import get_wsgi_application; get_wsgi_application()\" \n```",
    "analyzed_at": "2026-02-02T07:10:02.802587+00:00"
  },
  "246f30992dfd": {
    "analysis": "## An\u00e1lisis del Error\n\n### 1. **Resumen**\nLa aplicaci\u00f3n Django est\u00e1 experimentando errores de integridad de base de datos (IntegrityError) que han ocurrido 43 veces en los \u00faltimos 4 d\u00edas. El stack trace est\u00e1 truncado, pero indica un problema con restricciones de base de datos durante operaciones de escritura.\n\n### 2. **Causa Probable**\n- **Violaci\u00f3n de restricciones de base de datos**: Intentos de insertar/actualizar datos que violan:\n  - Claves primarias duplicadas\n  - Restricciones UNIQUE\n  - Claves for\u00e1neas inv\u00e1lidas\n  - Restricciones NOT NULL\n- **Condiciones de carrera**: M\u00faltiples requests simult\u00e1neos intentando crear el mismo registro\n- **Validaci\u00f3n insuficiente**: Datos no validados correctamente antes de llegar a la base de datos\n\n### 3. **Impacto**\n**Nivel: ALTO**\n- **Frecuencia significativa**: 43 ocurrencias en 4 d\u00edas indica un problema sistem\u00e1tico\n- **Funcionalidad cr\u00edtica**: Afecta la gesti\u00f3n de proveedores (funcionalidad de negocio core)\n- **Experiencia de usuario**: Los usuarios experimentan errores 500 en operaciones importantes\n- **Integridad de datos**: Riesgo de inconsistencias en la base de datos\n\n### 4. **Soluci\u00f3n Sugerida**\n\n#### **Inmediato:**\n```bash\n# 1. Revisar logs completos para identificar el campo espec\u00edfico\ngcloud logging read \"resource.type=cloud_run_revision AND resource.labels.service_name=gestion-proveedores-isa\" --limit=50\n\n# 2. Verificar integridad de la base de datos\npython manage.py check\npython manage.py makemigrations --check\n```\n\n#### **Correcci\u00f3n del c\u00f3digo:**\n```python\n# Implementar manejo de IntegrityError\nfrom django.db import IntegrityError, transaction\n\ndef create_proveedor(self, validated_data):\n    try:\n        with transaction.atomic():\n            return super().create(validated_data)\n    except IntegrityError as e:\n        # Log espec\u00edfico del error\n        logger.error(f\"IntegrityError en proveedor: {e}\")\n        raise ValidationError(\"Error de integridad de datos\")\n\n# Agregar validaci\u00f3n \u00fanica en el serializer\ndef validate(self, attrs):\n    if Model.objects.filter(campo_unique=attrs['campo']).exists():\n        raise ValidationError(\"Este valor ya existe\")\n    return attrs\n```\n\n### 5. **Prevenci\u00f3n**\n\n#### **Validaciones robustas:**\n- Implementar validaci\u00f3n en el serializer/form antes de llegar al modelo\n- Usar `get_or_create()` en lugar de `create()` cuando sea apropiado\n- Agregar validaci\u00f3n de unicidad en tiempo real\n\n#### **Manejo de concurrencia:**\n```python\nfrom django.db import transaction\n\n@transaction.atomic\ndef create_with_lock(self, **kwargs):\n    # Usar select_for_update() para evitar condiciones de carrera\n    pass\n```\n\n#### **Monitoreo:**\n- Configurar alertas espec\u00edficas para IntegrityError\n- Implementar logging detallado de validaciones fallidas\n- Revisar regularmente los constraints de la base de datos\n\n#### **Testing:**\n- Agregar tests para casos de duplicidad\n- Tests de carga para detectar condiciones de carrera\n- Validar todos los constraints en los tests de integraci\u00f3n",
    "analyzed_at": "2026-02-02T07:10:19.004149+00:00"
  },
  "dde6c375e4f9": {
    "analysis": "## An\u00e1lisis del Error - Aplicaci\u00f3n Django en Google Cloud Run\n\n### 1. **Resumen**\nLa aplicaci\u00f3n Django est\u00e1 devolviendo errores HTTP 500 en el endpoint `/notificaciones/no-leidas/` con una latencia extremadamente alta de ~12 segundos. El error se ha reproducido 43 veces en 4 d\u00edas, indicando un problema sistem\u00e1tico en la funcionalidad de notificaciones.\n\n### 2. **Causa Probable**\n- **Timeout de consulta a base de datos**: La alta latencia (12s) sugiere operaciones de BD lentas o bloqueos\n- **Consultas N+1 o queries mal optimizadas** en el modelo de notificaciones\n- **Conexiones de BD agotadas** o no liberadas correctamente\n- **Falta de \u00edndices** en las tablas relacionadas con notificaciones\n- **Memory leaks** o procesamiento ineficiente de grandes vol\u00famenes de datos\n\n### 3. **Impacto**\n**Nivel: ALTO**\n- Funcionalidad cr\u00edtica (notificaciones) completamente inutilizable\n- Experiencia de usuario muy degradada (12s de espera)\n- 43 ocurrencias indican que m\u00faltiples usuarios est\u00e1n afectados\n- Puede provocar timeouts en el frontend y abandono de la aplicaci\u00f3n\n\n### 4. **Soluci\u00f3n Sugerida**\n```python\n# Pasos inmediatos:\n1. Revisar logs detallados de Django:\n   - Activar DEBUG=True temporalmente en staging\n   - Revisar django.db.backends para queries lentas\n\n2. Optimizar consultas:\n   - Usar select_related() y prefetch_related()\n   - Implementar paginaci\u00f3n en notificaciones\n   - Agregar \u00edndices a campos de filtrado\n\n3. Configurar timeouts:\n   - DATABASES['default']['OPTIONS']['connect_timeout'] = 10\n   - Ajustar Cloud Run timeout settings\n\n4. Monitoreo:\n   - Implementar django-debug-toolbar\n   - Configurar alertas para queries >2s\n```\n\n### 5. **Prevenci\u00f3n**\n- **Implementar cache Redis** para notificaciones frecuentemente consultadas\n- **Configurar monitoring APM** (ej: Google Cloud Monitoring)\n- **Establecer limits de queries** en settings de Django\n- **Tests de performance** en CI/CD para endpoints cr\u00edticos\n- **Health checks** espec\u00edficos para funcionalidades core\n- **Database connection pooling** con pgBouncer o similar",
    "analyzed_at": "2026-02-02T07:10:32.500048+00:00"
  },
  "8b60a2c2fc9f": {
    "analysis": "## An\u00e1lisis del Error\n\n### 1. **Resumen**\nError 500 (Internal Server Error) en la URL de creaci\u00f3n de nuevas \u00f3rdenes de producci\u00f3n que se repite consistentemente durante 4 d\u00edas. El mensaje de error est\u00e1 vac\u00edo, lo que indica un fallo silencioso en el servidor Django.\n\n### 2. **Causa Probable**\n- **Excepci\u00f3n no capturada** en la vista Django que maneja `/produccion/ordenes/nueva/`\n- **Falta de logging** adecuado que impide ver el stacktrace del error\n- Posibles causas espec\u00edficas:\n  - Error de conexi\u00f3n a base de datos\n  - Problema con dependencias o imports\n  - Variables de entorno faltantes\n  - Error en templates o formularios\n\n### 3. **Impacto**\n**Nivel: ALTO**\n- Funcionalidad cr\u00edtica de producci\u00f3n completamente inoperativa\n- 38 ocurrencias indican que m\u00faltiples usuarios est\u00e1n afectados\n- Impacta directamente el flujo de trabajo de \u00f3rdenes de producci\u00f3n\n- Alta latencia (2.7 segundos) sugiere timeout o proceso colgado\n\n### 4. **Soluci\u00f3n Sugerida**\n```bash\n# Paso 1: Revisar logs detallados\ngcloud logging read \"resource.type=cloud_run_revision AND resource.labels.service_name=plasticos-ambientales\" --limit=50\n\n# Paso 2: Conectar a la instancia y revisar logs de Django\ngcloud run services logs read plasticos-ambientales --region=us-central1\n\n# Paso 3: Verificar configuraci\u00f3n\n- Revisar settings.py para DEBUG y LOGGING\n- Verificar variables de entorno en Cloud Run\n- Comprobar conectividad a base de datos\n\n# Paso 4: Deploy con logging mejorado\n- Agregar try/catch en la vista problem\u00e1tica\n- Configurar logging detallado en settings.py\n```\n\n### 5. **Prevenci\u00f3n**\n- **Implementar logging robusto** en todas las vistas cr\u00edticas\n- **Configurar alertas proactivas** para errores 500\n- **Agregar health checks** espec\u00edficos para endpoints cr\u00edticos\n- **Implementar tests automatizados** para flujos de \u00f3rdenes\n- **Configurar DEBUG=True** temporalmente en desarrollo para capturar errores\n- **Establecer monitoreo de disponibilidad** con herramientas como Uptime Check",
    "analyzed_at": "2026-02-02T07:10:47.310782+00:00"
  },
  "7094027ff185": {
    "analysis": "## An\u00e1lisis del Error - Django en Google Cloud Run\n\n### 1. **Resumen**\nError HTTP 500 recurrente (32 ocurrencias en 3 d\u00edas) en el endpoint de creaci\u00f3n de control de temperatura para materia prima. El error se produce consistentemente con una latencia baja (0.06s), sugiriendo un fallo inmediato en el procesamiento de la vista Django.\n\n### 2. **Causa Probable**\n- **Error de c\u00f3digo Python** en la vista `crear` del m\u00f3dulo de control de temperatura\n- **Problema de configuraci\u00f3n** de base de datos o migraciones faltantes\n- **Variables de entorno faltantes** o mal configuradas en Cloud Run\n- **Dependencias faltantes** o incompatibles en el contenedor\n- **Permisos insuficientes** para acceder a recursos (base de datos, storage, etc.)\n\n### 3. **Impacto**\n**Nivel: ALTO**\n- Funcionalidad cr\u00edtica de inventarios completamente inaccesible\n- 32 errores en 3 d\u00edas indica uso frecuente de esta funcionalidad\n- Afecta procesos operativos de control de calidad\n- Experiencia de usuario degradada con errores 500\n\n### 4. **Soluci\u00f3n Sugerida**\n```bash\n# 1. Revisar logs detallados de Cloud Run\ngcloud logging read \"resource.type=cloud_run_revision AND resource.labels.service_name=carnesdelsebastian\" --limit=50\n\n# 2. Verificar configuraci\u00f3n de Django\n- Activar DEBUG temporalmente para obtener stack trace completo\n- Revisar settings.py para configuraci\u00f3n de DATABASES\n- Validar variables de entorno en Cloud Run\n\n# 3. Verificar c\u00f3digo de la vista\n- Revisar views.py del m\u00f3dulo inventarios/materia-prima/control-temperatura\n- Verificar imports, modelos y formularios relacionados\n\n# 4. Validar base de datos\n- Ejecutar migraciones pendientes\n- Verificar conectividad a la base de datos desde Cloud Run\n```\n\n### 5. **Prevenci\u00f3n**\n- **Logging mejorado**: Implementar logging detallado con Django logging framework\n- **Monitoring proactivo**: Configurar alertas en Google Cloud Monitoring para errores 500\n- **Testing automatizado**: Crear tests unitarios/integraci\u00f3n para todas las vistas cr\u00edticas\n- **Health checks**: Implementar endpoint de health check que valide dependencias\n- **Staging environment**: Desplegar cambios en entorno de pruebas antes de producci\u00f3n\n- **Error handling**: Implementar manejo de excepciones espec\u00edfico en las vistas Django\n\n**Acci\u00f3n inmediata recomendada**: Revisar los logs de aplicaci\u00f3n de Cloud Run para obtener el stack trace completo del error.",
    "analyzed_at": "2026-02-02T07:11:02.284256+00:00"
  },
  "b859899768a4": {
    "analysis": "## An\u00e1lisis del Error\n\n### 1. **Resumen**\nLa aplicaci\u00f3n Django no puede conectarse a la base de datos PostgreSQL en Cloud SQL debido a un fallo de autenticaci\u00f3n. El usuario \"postgres\" est\u00e1 siendo rechazado por credenciales incorrectas.\n\n### 2. **Causa Probable**\n- **Credenciales incorrectas**: La contrase\u00f1a del usuario \"postgres\" en la configuraci\u00f3n de Django no coincide con la almacenada en Cloud SQL\n- **Variables de entorno**: Posible problema con las variables de entorno que contienen las credenciales de la BD\n- **Rotaci\u00f3n de contrase\u00f1as**: La contrase\u00f1a pudo haber sido cambiada en Cloud SQL sin actualizar la aplicaci\u00f3n\n\n### 3. **Impacto**\n**Nivel: CR\u00cdTICO**\n- La aplicaci\u00f3n no puede acceder a datos\n- 32 ocurrencias en ~6 horas indica fallo sistem\u00e1tico\n- Afecta toda la funcionalidad que requiera base de datos\n- Experiencia de usuario completamente comprometida\n\n### 4. **Soluci\u00f3n Sugerida**\n\n**Pasos inmediatos:**\n1. **Verificar credenciales en Cloud SQL Console**\n   - Confirmar usuario \"postgres\" existe y est\u00e1 activo\n   - Resetear contrase\u00f1a si es necesario\n\n2. **Actualizar configuraci\u00f3n de Django**\n   ```bash\n   # Verificar variables de entorno en Cloud Run\n   gcloud run services describe gestion-proveedores-isa --region=us-central1\n   ```\n\n3. **Actualizar secretos**\n   ```bash\n   # Actualizar variable de entorno con nueva contrase\u00f1a\n   gcloud run services update gestion-proveedores-isa \\\n     --set-env-vars DB_PASSWORD=nueva_contrase\u00f1a\n   ```\n\n4. **Verificar conexi\u00f3n Cloud SQL**\n   - Confirmar que el socket Unix est\u00e1 correctamente configurado\n   - Validar permisos del service account\n\n### 5. **Prevenci\u00f3n**\n\n- **Gesti\u00f3n de secretos**: Usar Google Secret Manager en lugar de variables de entorno\n- **Monitoreo**: Implementar alertas proactivas de conectividad de BD\n- **Documentaci\u00f3n**: Mantener registro de cambios de credenciales\n- **Testing**: Incluir verificaci\u00f3n de conexi\u00f3n BD en health checks\n- **Backup de configuraci\u00f3n**: Mantener respaldo de configuraciones funcionales",
    "analyzed_at": "2026-02-02T07:11:14.341096+00:00"
  },
  "4711160f70ba": {
    "analysis": "## An\u00e1lisis del Error Django - FieldError\n\n### 1. **Resumen**\nError `FieldError` en Django al intentar realizar una agregaci\u00f3n con `Avg()` sobre un campo que probablemente no existe o no es accesible en el QuerySet. El error ocurre en una vista de reportes de producci\u00f3n cuando se intenta procesar datos del a\u00f1o anterior.\n\n### 2. **Causa Probable**\n- El campo `campo_hist` utilizado en `Avg(campo_hist)` no existe en el modelo o tabla consultada\n- Posible error de tipeo en el nombre del campo\n- El campo existe pero no es del tipo correcto para agregaciones num\u00e9ricas\n- Problema de migraci\u00f3n donde el campo fue eliminado pero el c\u00f3digo no se actualiz\u00f3\n\n### 3. **Impacto**\n**Nivel: ALTO**\n- 31 ocurrencias en ~37 minutos indica un problema frecuente\n- Afecta funcionalidad de reportes de producci\u00f3n (cr\u00edtica para el negocio)\n- Bloquea completamente la vista cuando se accede\n- Puede impactar la toma de decisiones operativas\n\n### 4. **Soluci\u00f3n Sugerida**\n```python\n# Pasos inmediatos:\n1. Verificar el modelo y confirmar nombre correcto del campo:\n   - Revisar apps/reportes/models.py\n   - Confirmar que 'campo_hist' existe y es num\u00e9rico\n\n2. Corregir la l\u00ednea 331 en views_produccion.py:\n   # Antes\n   for registro in qs_hist.values('mes').annotate(valor=Avg(campo_hist)):\n   \n   # Despu\u00e9s (ejemplo)\n   for registro in qs_hist.values('mes').annotate(valor=Avg('campo_historico')):\n\n3. Agregar validaci\u00f3n defensiva:\n   try:\n       for registro in qs_hist.values('mes').annotate(valor=Avg('campo_correcto')):\n           # procesamiento\n   except FieldError as e:\n       logger.error(f\"Campo no encontrado: {e}\")\n       return JsonResponse({'error': 'Campo no disponible'})\n```\n\n### 5. **Prevenci\u00f3n**\n- **Testing**: Implementar tests unitarios para validar todas las consultas ORM\n- **Linting**: Usar herramientas como `django-migration-linter`\n- **Code Review**: Revisar cambios en modelos y sus impactos en vistas\n- **Monitoreo**: Configurar alertas para errores `FieldError` en producci\u00f3n\n- **Documentaci\u00f3n**: Mantener documentaci\u00f3n actualizada de campos de modelos",
    "analyzed_at": "2026-02-02T07:11:26.988748+00:00"
  },
  "2a904eba5a66": {
    "analysis": "## An\u00e1lisis del Error - Cloud Run STARTUP TCP Probe Failed\n\n### 1. **Resumen**\nLa aplicaci\u00f3n Django en Cloud Run no puede iniciarse correctamente porque el contenedor no responde en el puerto 8080 durante el proceso de arranque. El probe de salud TCP est\u00e1 fallando consistentemente, impidiendo que la instancia se marque como lista para recibir tr\u00e1fico.\n\n### 2. **Causa Probable**\n- **Puerto incorrecto**: Django no est\u00e1 configurado para escuchar en el puerto 8080\n- **Tiempo de arranque excesivo**: La aplicaci\u00f3n tarda m\u00e1s tiempo del permitido en inicializarse\n- **Error en el c\u00f3digo**: Excepci\u00f3n durante el startup que impide que el servidor web inicie\n- **Configuraci\u00f3n de Gunicorn/uWSGI**: Servidor WSGI mal configurado o no ejecut\u00e1ndose\n\n### 3. **Impacto**\n**Nivel: CR\u00cdTICO**\n- La aplicaci\u00f3n est\u00e1 completamente inaccesible (29 fallos consecutivos)\n- Tiempo de inactividad prolongado (m\u00e1s de 2 horas)\n- Los usuarios no pueden acceder al servicio\n- P\u00e9rdida potencial de datos/transacciones\n\n### 4. **Soluci\u00f3n Sugerida**\n\n**Verificaciones inmediatas:**\n```bash\n# 1. Verificar configuraci\u00f3n del puerto\n# En settings.py o variable de entorno\nPORT = os.environ.get('PORT', 8080)\n\n# 2. Verificar comando de inicio en Dockerfile\nCMD exec gunicorn --bind :$PORT --workers 1 --threads 8 myapp.wsgi:application\n\n# 3. Aumentar timeout de startup en Cloud Run\ngcloud run services update moldes-mecanizados-app \\\n  --timeout=900 \\\n  --cpu-boost\n```\n\n**Diagn\u00f3stico:**\n```bash\n# Revisar logs del contenedor\ngcloud logging read \"resource.type=cloud_run_revision AND resource.labels.service_name=moldes-mecanizados-app\" --limit=50\n\n# Probar localmente\ndocker run -p 8080:8080 [imagen] \ncurl http://localhost:8080/\n```\n\n### 5. **Prevenci\u00f3n**\n\n**Configuraciones recomendadas:**\n- **Health check personalizado**: Implementar endpoint `/health/` en Django\n- **Startup probe configurado**: Definir probe con timeout adecuado\n- **Monitoreo**: Configurar alertas proactivas de Cloud Monitoring\n- **Testing**: Validar imagen Docker localmente antes del deploy\n- **Graceful startup**: Implementar inicializaci\u00f3n as\u00edncrona para dependencias pesadas\n\n**Dockerfile optimizado:**\n```dockerfile\nEXPOSE 8080\nENV PORT 8080\nHEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:$PORT/health/ || exit 1\n```",
    "analyzed_at": "2026-02-02T07:11:41.576363+00:00"
  }
}